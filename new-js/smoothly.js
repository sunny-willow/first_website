!function(t){ //это функциональное выражение (позволяет немедленно вызвать функцию), это не объявление функции
//t - это window???
//в теле функции код будет вполняться после вызова функции
/*WeakMap (в отличие от Map) не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.
Ключи должны быть объектами.
Если мы работаем с объектом, который "принадлежит" другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него,
которые должны существовать лишь пока существует объект, то WeakMap - как раз то, что нужно.
Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.*/
    const e = new WeakMap, n = (t, e, n) => //стрелочная функция n вернет результат выражения после => (если параметр один, то можно опустить круглые скобки)
//функцию n можно вызвать с любыми аргументами
//внешний код, получив промис, навесит на него обработчики результата и ошибки (или чего-то одного)
//обработчики событий - это функции, которые вызываются в ответ на определенное событие. Это может быть, например, щелчок мыши.
        new Promise(o => { //функция с параметром "o" будет вызвана автоматически
//в ней можно делать любые асинхронные операции
//когда асинхронные операции завершатся - нужно вызвать одно из:
// resolve(результат) при успешном выполнении (здесь только resolve - вызов функции с параметром "o" в случае успешного выполнения)
// или reject(ошибка) при ошибке (если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject)
//параметр "o" вместо (resolve, reject)
            const s = () => { //многострочная стрелочная функция (если нужно вернуть значение, то должен присутствовать return, но его нет)
                t.removeEventListener("transitionend", s); //заменила здесь на точку с запятой вместо запятой - работает также
                o() //вызов resolve и выход, new Promise возвращает объект Promise, который представляет результат асинхронной операции.
                //в скобочках после "o" должен был быть возвращаемый результат, но он нам не нужен, по сути будет возвращать undefined
            };
            //удаляет обработчик события с элемента t
            //transitionend - событие, на которое был назначен обработчик (срабатывает при завершении css-перехода)
            //s - функция-обработчик, которую нужно удалить
            //o() - вызов функции, почему перед ней была запятая?
            t.style[e] = n; //здесь также после n стояла запятая, я заменила её на ;
            //видно это тоже многострочная стрелочная функция в Promise, она не возвращает по умолчанию результат инструкции, а просто выполняет инструкции через запятую или точку с запятой
            t.addEventListener("transitionend", s)
        });
            //здесь s - станет функцией, которая будет выполняться после завершения css-перехода
        //в изначальном коде следующего const не было, как и в других местах выше, все переменные задавались через запятую, нечитаемо абсолютно
    const o = t => n(t, "opacity", 0); //только здесь код пошёл выполнять промис в первый раз, выше мы его лишь определили
    //полностью исчезнет объект
    //n(t, "opacity", 0) вернет undefined, как и говорилось выше
    const s = t => n(t, "opacity", 1);
    //появится без прозрачности

//цепочка промисов
/*
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
*/

//e - возвращает новый объект WeakMap
//похоже вторая скобочка закидывает в немедленно выполняемую функцию значение 1e3 на место параметра t?
    const i = t => (t => new Promise(e => setTimeout(e, t)))(1e3) //1e3 = 10^3 = 1000 (console.log перед setTimeout всегда показывает t == 1000)
//setTimeout позволяет вызвать функцию "e" один раз через определённый интервал времени (t = 1 секунду = 1000 милисекунд)
//setTimeout возвращает числовой идентификатор таймера (timeoutID - положительное целое число, которое определяет таймер, созданный в результате вызова метода)
//колбэки - это функции, которые передаются в другие функции в качестве аргументов и вызываются после завершения определенной задачи
//используются в асинхронных операциях, таких как сетевые запросы и таймеры
//на промис можно навешивать колбэки двух типов:
//onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно»
//onReject – срабатывают, когда promise в состоянии «выполнен с ошибкой»
//.then(onFulfilled, onReject)
// promise.then(null, onRejected) - сработает при ошибке, тоже самое сделает .catch(onRejected)
    //вроде если промис выдал успешный результат, то мы с этим результатом идем в then.
    //если выполнился первый then, то идём в следующий then и далее по цепочке
    //нужно учитывать, что через t (1 с) в любом случае мы перейдём в функцию "e"
        .then(() => o(t)) //возвращает новый объект промиса, изменив объект промиса, к которому он был вызван, добавляя обработчики во внутренний список
        //т.о., обработчик сохраняется в исходном промисе, и срок его действия не превышает срок действия исходного промиса.
        //смотри пример выше с передачей функции result
        //сделали объекту css-свойство opacity: 0;
        .then(() => {
            const n = e.get(t); //n = значение по ключу t
            /*console.log(n);
            console.log(n.prop); //prop даст имя свойства css текстом
            console.log(n.contents); //массив элементов, предначначенных к замене*/
            //shift() удаляет первый элемент массива, уменьшает его длину на единицу и возвращает удалённое значение
            return t[n.prop] = n.contents.shift(), s(t)
            //здесь объекту t по ключу n.prop (свойству) присваивается удаленное значение после обработки массива contents
            //сделали объекту css-свойство opacity: 1;
            //кажется prop и contents из JQuery, но у нас это ключи объекта, там ещё есть timer (это всё ниже задаётся)
        })
        //если длина массива contents > 0 тогда i(t), иначе после :
        .then(() => e.get(t).contents.length ? //выполняется ли условие перед ?, если да, то функция перед :, а если нет, то функция после :
        i(t) :
        (t => {
            e.get(t).timer = null //обнуляем таймер
        })(t)); //закидываем наш объект в немедленно выполняемую функцию, кажется?

/*function smoothly(element, key, newObject)*/
    //задаём ключ smoothly? и присваиваем то, что лежит по ключу?
    t.smoothly = ((t, n, r) => {
        ((t, n) => 
            //has() позволяет проверить существование значения для заданного ключа
            //true, если запись с указанным ключом существует в объекте WeakMap
            //false, если ключ не является объектом или незарегистрированным символом
            e.has(t) || (t.style.transition = n) //кладем в свойство transition - all 0.5s ease-in-out
            //объект либо уже есть, либо мы что-то делаем?
            //transition в css позволяет создавать плавные переходы между двумя состояниями элемента при изменении одного или нескольких свойств
        //false будет только в случае обоих ложных операторах        
        )(t, "all 0.5s ease-in-out"); //здесь вместо запятой в многострочной стрелочной опять точка с запятой
        //каскадные таблицы стилей пошли
        //all - применить ко всем изменённым свойствам
        //Ease-in-out — комбинация функций ease-in и ease-out: анимация начинается медленно,
        //ускоряется в средней части перехода, а затем замедляется к концу
        //0.5s - длительность

        e.has(t) || e.set(t, {prop: n, contents: [], timer: null});
        //добавляем новую запись set(ключ, значение - объект) - возвращает объект WeakMap
        const c = e.get(t); //c - значение по ключу t
        c.contents.push(r); //добавляет один или несколько элементов в конец массива и возвращает новую длину массива
        c.timer || (c.timer = setTimeout(() => {
            if(c.contents.length > 1)
                return i(t); //выходим отсюда и идём к i(t), если объект 1, то продолжаем
            c.timer = null;
            (t => o(t) //делаем объект невидимым и возвращаем наш промис (или результат)
                .then(() => {
                    const n = e.get(t); //n = значение по ключу t
                    return t[n.prop] = n.contents.shift(), s(t) //делает абсолютно то же самое, что и второй then функции i(t)
                }))(t)
        }, 0)) //выполнит сразу после завершения кода
        /*Даже если задержка установлена на 0, функция не выполнится мгновенно.
        Вместо этого она добавляется в очередь событий и будет выполнена после того, как выполнится текущий код.
        Это связано с особенностями работы цикла событий (event loop) в JavaScript:
        код срабатывает не раньше чем через указанную задержку, но точный момент зависит от текущей загрузки потока*/
    })
//похоже скобочки - это немедленно вызываемые функции (IIFE, immediately invoked function expression)
//немедленно вызываемое функциональное выражение или executing anonymous function (самоисполняющаяся анонимная функция)
//такие функции заключаются в скобки, и после определения ф. в скобках происходит передача параметров.
//это позволяет вызвать функцию сразу при её определении
}(window); //в последних скобках можно расположить код, который будет выполняться при вызове функции
//window - глобальный объект, центр управления операциями js в браузере, он позволяет управлять браузером