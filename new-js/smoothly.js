/*
код работает так, что приводит объект в opacity 0, затем заменяет объект на новый, далее делает новый объект явным (opacity 1)
*/

!function(v){ //это функциональное выражение, это не объявление функции
//оно позволяет немедленно вызвать функцию, т.к. функциональное выражение создается только после того, как интерпретатор доходит до него
//v - это window
//в теле функции код будет вполняться после вызова функции

/*WeakMap (в отличие от Map) не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.
Ключи должны быть объектами.
Если мы работаем с объектом, который "принадлежит" другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него,
которые должны существовать лишь пока существует объект, то WeakMap - как раз то, что нужно.
Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.*/
    const e = new WeakMap, b = (t, propertyCSS, num) => //стрелочная функция b вернет результат выражения после => (если параметр один, то можно опустить круглые скобки)
//эта функция меняет значение opacity на 0 или 1, далее ждёт, когда css-переход закончится и удаляет обработчик события.
//а вот каким будет css переход задаётся в v.smoothly в t.style.transition
//внешний код, получив промис (результат функции b()), навесит на него обработчики результата (это уже then ниже) и ошибки (или чего-то одного)
        new Promise(r => { //функция с параметром-функцией "r" будет вызвана автоматически
//в ней можно делать любые асинхронные операции
//когда асинхронные операции завершатся - нужно вызвать одно из:
//resolve(результат) при успешном выполнении (здесь только resolve - вызов функции с параметром "r" в случае успешного выполнения)
//или reject(ошибка) при ошибке (если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject)
//параметр "r" вместо (resolve)
            const g = () => { //многострочная стрелочная функция (если нужно вернуть значение, то должен присутствовать return, но его нет)
                t.removeEventListener("transitionend", g); //заменила здесь на точку с запятой вместо запятой - работает также
                r() //вызов resolve и выход, new Promise возвращает объект Promise, который представляет результат асинхронной операции.
                //в скобочках после "r" должен был быть возвращаемый результат, но он нам не нужен, по сути будет возвращать undefined
            };
            //удаляет обработчик события с элемента t
            //transitionend - событие, на которое был назначен обработчик (срабатывает при завершении css-перехода)
            //g - функция-обработчик, которую нужно удалить
            t.style[propertyCSS] = num; //здесь также после num стояла запятая, я заменила её на ;
            //видно это тоже многострочная стрелочная функция в Promise, она не возвращает по умолчанию результат инструкции, а просто выполняет инструкции через запятую или точку с запятой
            t.addEventListener("transitionend", g) //здесь g - станет функцией, которая будет выполняться после завершения css-перехода
        });

    //в изначальном коде следующего const не было, как и в других местах выше, все переменные задавались через запятую, нечитаемо абсолютно
    const o = t => b(t, "opacity", 0); //только здесь код пошёл выполнять промис в первый раз, выше мы его лишь определили в функции b()
    //полностью исчезнет объект
    //b(t, "opacity", 0) вернет undefined, как и говорилось выше (потому что в скобочках фунции r() пусто)
    //но он хранит объект Promise, который и будет дальше использоваться
    const s = t => b(t, "opacity", 1);
    //появится без прозрачности, максимально явно

//Принцип работы цепочки промисов

/*new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*) //код стартует через 1 с

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then((result) => { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result3) { // (****)

  alert(result3); // 4
  return result3 * 2;

});*/

//t - это объект по классу css
//e - возвращает новый объект WeakMap
//вторая скобочка закидывает в немедленно выполняемую функцию (в функциональное выражение) значение 1e3 на место параметра time
//похоже после первой => тут возвращается анонимная функция (функция на короткий срок)
//вместо следующей строки можно было бы написать яснее:
//const i = t => function(time) {return new Promise(a => setTimeout(a, time))}(1e3)
//запись со скобочками мне не совсем понятна, слишком просто возвращаем анонимную функцию в скобке, закидывая в неё параметр в другой скобке  
//функция i(t) вызывает переход к opaity 0, затем уменьшает массив требуемых к изменению свойств на 1,
//передаёт удаленное значение в обработку к opacity 1 и снова вызывает себя же, если в массиве ещё есть элементы
    const i = t => ((time) => new Promise(a => setTimeout(a, time)))(1e3) //1e3 = 10^3 = 1000 (console.log перед setTimeout всегда показывает time == 1000)
//setTimeout позволяет вызвать функцию с параметром "a" (resolve) один раз через определённый интервал времени (t = 1 секунду = 1000 милисекунд)
//setTimeout возвращает числовой идентификатор таймера (timeoutID - положительное целое число, которое определяет таймер, созданный в результате вызова метода)

/*колбэки - это функции, которые передаются в другие функции в качестве аргументов и вызываются после завершения определенной задачи
используются в асинхронных операциях, таких как сетевые запросы и таймеры
на промис можно навешивать колбэки двух типов:
onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно»
onReject – срабатывают, когда promise в состоянии «выполнен с ошибкой»
.then(onFulfilled, onReject)
promise.then(null, onRejected) - сработает при ошибке, тоже самое сделает .catch(onRejected)*/

    //вроде если промис выдал успешный результат, то мы с этим результатом идем в then.
    //если выполнился первый then, то идём в следующий then и далее по цепочке
        .then(() => o(t)) //возвращает новый объект промиса, изменив объект промиса, к которому он был вызван, добавляя обработчики во внутренний список
        //т.о., обработчик сохраняется в исходном промисе, и срок его действия не превышает срок действия исходного промиса.
        //смотри пример выше с передачей функции result
        //сделали объекту css-свойство opacity: 0;
        .then(() => { //вынести функцию в этом then отдельно у меня не получилось, оставила в повторении
            const z = e.get(t); //z = значение по ключу t
            /*console.log(z); //объект с тремя ключами prop, contents и timer будет значением по ключу t
            console.log(z.prop); //prop даст имя атрибута html (или как я назвала propertyHTML) текстом
            console.log(z.contents); //массив элементов, предначначенных к замене*/
            //shift() удаляет первый элемент массива, уменьшает его длину на единицу и возвращает удалённое значение
            t[z.prop] = z.contents.shift()
            //здесь объекту t по ключу z.prop (свойству) присваивается удаленное значение после обработки массива contents
            //кажется prop и contents из JQuery, но у нас это ключи объекта, там ещё есть timer (это всё ниже задаётся)
            s(t); //сделали объекту css-свойство opacity: 1;
        })
        //если длина массива contents > 0 тогда i(t), иначе после :
        .then(() => e.get(t).contents.length ? //выполняется ли условие перед ?, если да, то функция перед :, а если нет, то функция после :
        i(t) :
        (t => {
            e.get(t).timer = null //обнуляем таймер
        })(t)); //закидываем наш объект t в анонимную функцию (опять через скобочки)

/*function smoothly(element, key, newObject)*/
    //выполнение кода стартует именно отсюда
    //задаём window ключ smoothly и присваиваем значение, которое будет лежать по этому ключу
    //видимо таким образом задаём существование функции smoothly в нашем проекте (браузере)
    v.smoothly = ((t, propertyHTML, newObject) => {
        ((t, meaningCSS) => 
            //has() позволяет проверить существование значения для заданного ключа
            //true, если запись с указанным ключом существует в объекте WeakMap
            //false, если ключ не является объектом или незарегистрированным символом
            e.has(t) || (t.style.transition = meaningCSS) //кладем в свойство transition - all 0.5s ease-in-out
            //false будет только в случае двух ложных операторов 
            //объект должен быть
            //transition в css позволяет создавать плавные переходы между двумя состояниями элемента при изменении одного или нескольких свойств css
            //в нашем случае он будет изменять одно свойство opacity (его можно написать вместо all)
        )(t, "all 0.5s ease-in-out"); //здесь вместо запятой в многострочной стрелочной опять точка с запятой
        //каскадные таблицы стилей пошли
        //all - применить ко всем изменённым свойствам (можно указать конкретное свойство или несколько)
        //Ease-in-out — комбинация функций ease-in и ease-out: анимация начинается медленно,
        //ускоряется в средней части перехода, а затем замедляется к концу
        //0.5s - длительность

        e.has(t) || e.set(t, {prop: propertyHTML, contents: [], timer: null});
        //добавляем новую запись set(ключи и их значения в объекте) - возвращает объект WeakMap
        const z = e.get(t); //z - значение по ключу t (объект с тремя ключами prop, contents и timer)
        z.contents.push(newObject); //добавляет один или несколько элементов в конец массива и возвращает новую длину массива
        //в нашем случае один
        z.timer || (z.timer = setTimeout(() => {
            if(z.contents.length > 1)
                return i(t); //выходим отсюда и идём к i(t), если объект 1, то продолжаем
            z.timer = null;
            (t => o(t) //делаем объект невидимым и возвращаем наш промис (или результат)
                .then(() => {
                    const z = e.get(t); //z = значение по ключу t
                    t[z.prop] = z.contents.shift(); //уменьшаем массив и определяем в значение по ключу объекта t - новый объект, на который изменится предыдущий
                    s(t); //делает объект видимым
                }))(t)
        }, 0)) //выполнит сразу после завершения кода
        /*Даже если задержка установлена на 0, функция не выполнится мгновенно.
        Вместо этого она добавляется в очередь событий и будет выполнена после того, как выполнится текущий код.
        Это связано с особенностями работы цикла событий (event loop) в JavaScript:
        код срабатывает не раньше чем через указанную задержку, но точный момент зависит от текущей загрузки потока*/
    })
//похоже скобочки - это немедленно вызываемые функции (IIFE, immediately invoked function expression)
//немедленно вызываемое функциональное выражение или executing anonymous function (самоисполняющаяся анонимная функция)
//такие функции заключаются в скобки, и после определения ф. в скобках происходит передача параметров.
//это позволяет вызвать функцию сразу при её определении
}(window);
//window - глобальный объект, центр управления операциями js в браузере, он позволяет управлять браузером
//тут же заставили сработать функцию после её объявления, будто function(window); написали ниже